.###  This whole script runs in template mode.
.#
.template 1
.gsl from "scripts/inherit_msg.gsl"
.path = "generated/doc/$(class.module:Pascal,lower)"
.output path + "/$(class.name:Pascal,lower).md"
.
.mtname = "../machinetalk-protobuf.md"
.
.macro recurse_field (scp, msg, indent)
.  for my.scp.field
.    qTerm = "one"
.    qS = ""
.    if (defined(field.quantity) & (field.quantity = "1+"))
.      qTerm = "one or more"
.      qS = "s"
.    endif
.    msgWord = ((my.msg = "Container") ?? "The" ? "Each")
.    if (defined(field.message))
$(my.indent)* $(msgWord) [$(my.msg:)]($(mtname)#pb.$(my.msg:)) message [$(REQUIREMENT)](https://www.ietf.org/rfc/rfc2119.txt) carry $(qTerm) [$(field.message:)]($(mtname)#pb.$(field.message:)) message$(qS).  
.      if (defined(field.synced) & (field.synced = "true"))
$(my.indent) This message is used for syncing. That means that all fields defined in
$(my.indent) [$(field.message:)]($(mtname)#pb.$(field.message:)) MAY be carried by this message.
.      else
.         recurse_field(field, field.message, "  " + my.indent)
.      endif
.    else
$(my.indent)* $(msgWord) [$(my.msg:)]($(mtname)#pb.$(my.msg:)) message [$(REQUIREMENT)](https://www.ietf.org/rfc/rfc2119.txt) carry $(qTerm) [$(name:)]($(mtname)#pb.$(my.msg:).$(name:)) field$(qS).
.    endif
.  endfor
.  for my.scp.oneof
$(my.indent)* $(msgWord) [$(my.msg:)]($(mtname)#pb.$(my.msg:)) message [$(REQUIREMENT)](https://www.ietf.org/rfc/rfc2119.txt) carry one of the following fields
.    for field
$(my.indent)$("  ")* [$(name:)]($(mtname)#pb.$(my.msg:).$(name:))
.    endfor
.  endfor
.endmacro
.
.for include
.  class.load_file("models/$(class.module:Pascal,lower)/" + filename)
.endfor
.
[//]: # (This file was autogenerated by docgen.gsl. Editing this file will result in loss of data.)
# $(name:)
$(class:no,left)
.
## Messages
.for message where (name <> "*")
<a name="msg_$(name:c)" />
### $(NAME)
$(message:no,left)
.
.- output all data fields
.  if (count(field) > 0)
#### Data Fields
.    recurse_field(message, "Container", "")

.  endif
.- output all response messages
.  if (count(response) > 0)
#### Possible Responses
.    for response
* [$(NAME)](#msg_$(name:c))
.    endfor

.  endif
.
.- find which messages this responds to
.  for class.message as msg
.    for response
.       if (name = message.name)
.         copy msg to message as responseto
.       endif
.    endfor
.  endfor
.
.  if (count(responseto) > 0)
#### Response to
.    for responseto
* [$(NAME)](#msg_$(name:c))
.    endfor

.  endif
.
.endfor
.
.for class
## $(class.name:)
$(class:no,left)
## State Machine
![State Machine]($(class.name:Pascal,lower).dot.svg)
.endfor
.
.endtemplate
